(function(){"use strict";class M{nextDouble(){return Math.random()}}class N{constructor(){this.graphHeight=500,this.graphWidth=500,this.random=new M,this.focusedNode=null}setDimensions(t,i){this.graphWidth=t,this.graphHeight=i}setFocusedNode(t){this.focusedNode=t}}const R=1e3,P=.8,T=.4,v=.25,D=.15,w=40,f=1e-4,g=25;class o{constructor(t,i){this.x=t,this.y=i}add(t){return new o(this.x+t.x,this.y+t.y)}subtract(t){return new o(this.x-t.x,this.y-t.y)}divide(t){return new o(this.x/t,this.y/t)}get distance(){return Math.sqrt(this.x*this.x+this.y*this.y)}limit(t){const i=this.distance;return i>t?this.divide(i).multiply(t):this}multiply(t){return new o(this.x*t,this.y*t)}normalize(){return this.divide(this.distance)}rotate(t){const i=Math.cos(t),s=Math.sin(t);return new o(this.x*i-this.y*s,this.x*s+this.y*i)}}o.zero=new o(0,0);class c{constructor(t,i,s,e){this.x=t,this.y=i,this.width=s,this.height=e}static fromLTRB(t,i,s,e){return new c(t,i,s-t,e-i)}static fromSize(t){return new c(0,0,t.width,t.height)}static fromPoints(t,i){return c.fromLTRB(Math.min(t.x,i.x),Math.min(t.y,i.y),Math.max(t.x,i.x),Math.max(t.y,i.y))}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get size(){return{width:this.width,height:this.height}}moveTo(t,i){return new c(t,i,this.width,this.height)}translate(t,i){return this.moveTo(this.x+t,this.y+i)}get center(){return new o(this.x+this.width/2,this.y+this.height/2)}}c.zero=new c(0,0,0,0);class S{constructor(){this.nodes=[],this.rect=c.zero}getNodes(){return this.nodes}getRect(){return this.rect}setRect(t){this.rect=t}add(t){this.nodes.push(t),this.nodes.length===1?this.rect=c.fromLTRB(t.x,t.y,t.x+t.width,t.y+t.height):this.rect=c.fromLTRB(Math.min(this.rect.left,t.x),Math.min(this.rect.top,t.y),Math.max(this.rect.right,t.x+t.width),Math.max(this.rect.bottom,t.y+t.height))}contains(t){return this.nodes.indexOf(t)!==-1}size(){return this.nodes.length}concat(t){t.nodes.forEach(i=>{i.position=new o(this.rect.right+w,this.rect.top),this.add(i)})}offset(t,i){this.nodes.forEach(s=>{s.position=s.position.add(new o(t,i))}),this.rect=this.rect.translate(t,i)}}class I extends N{constructor(){super(...arguments),this.displacement=new Map,this.tick=0,this.iterations=R,this.repulsionRate=P,this.attractionRate=v,this.repulsionPercentage=T,this.attractionPercentage=D}setProperties(t){t!=null&&t.iterations&&(this.iterations=t.iterations),t!=null&&t.repulsionRate&&(this.repulsionRate=t.repulsionRate),t!=null&&t.attractionRate&&(this.attractionRate=t.attractionRate),t!=null&&t.repulsionPercentage&&(this.repulsionPercentage=t.repulsionPercentage),t!=null&&t.attractionPercentage&&(this.attractionPercentage=t.attractionPercentage)}init(t){t.nodes.forEach(i=>{this.displacement.set(i,o.zero);const s=this.random.nextDouble()*this.graphWidth,e=this.random.nextDouble()*this.graphHeight;i.position=new o(s,e)})}copyPositions(t){t.nodes.forEach(i=>{this.displacement.set(i,i.position)})}moveNodes(t){t.nodes.forEach(i=>{const s=i.position.add(this.displacement.get(i)),e=Math.min(this.graphWidth-40,Math.max(0,s.x)),n=Math.min(this.graphHeight-40,Math.max(0,s.y));i.position=new o(e,n)})}cool(t){this.tick*=1-t/this.iterations}limitMaximumDisplacement(t){t.forEach(i=>{if(i!==this.focusedNode){debugger;const s=this.displacement.get(i),e=s.distance,n=Math.max(f,e),h=n*Math.min(n,this.tick),r=s.divide(h);i.position=i.position.add(r)}else this.displacement.set(i,o.zero)})}calculateAttraction(t){t.forEach(i=>{const s=i.source,e=i.destination,n=s.position.subtract(e.position),h=Math.max(f,n.distance),r=Math.min(this.graphWidth*this.attractionPercentage,this.graphHeight*this.attractionPercentage),a=Math.min(0,Math.abs(r-h)/(r*2)),E=n.multiply(a*this.attractionRate);this.displacement.set(s,this.displacement.get(s).subtract(E)),this.displacement.set(e,this.displacement.get(e).add(E))})}calculateRepulsion(t){t.forEach(i=>{t.forEach(s=>{if(i!==s){const e=i.position.subtract(s.position),n=Math.max(f,e.distance),h=Math.min(this.graphWidth*this.repulsionPercentage,this.graphHeight*this.repulsionPercentage),r=Math.max(0,h-n)/h,a=e.multiply(r*this.repulsionRate);this.displacement.set(i,this.displacement.get(i).add(a))}}),t.forEach(s=>{this.displacement.set(s,this.displacement.get(s).divide(t.length))})})}layout(t){const i=this.findBiggestSize(t)*t.nodes.length;this.graphWidth=i,this.graphHeight=i}run(t,i,s){this.layout(t);const e=t.nodes,n=t.edges;this.tick=.1*Math.sqrt(this.graphWidth/2*this.graphHeight/2),this.init(t);for(let h=0;h<this.iterations&&(this.calculateRepulsion(e),this.calculateAttraction(n),this.limitMaximumDisplacement(e),this.cool(h),!this.done());h++);return this.focusedNode===null&&this.positionNodes(t),this.shiftCoordinates(t,i,s),this.calculateGraphSize(t)}step(t){this.displacement.clear(),t.nodes.forEach(i=>{this.displacement.set(i,o.zero)}),this.calculateRepulsion(t.nodes),this.calculateAttraction(t.edges),this.moveNodes(t)}shiftCoordinates(t,i,s){t.nodes.forEach(e=>{e.position=e.position.add(new o(i,s))})}positionNodes(t){const i=this.getOffset(t),s=i.x,e=i.y,n=[],h=[];t.nodes.forEach(r=>{r.position=r.position.subtract(new o(s,e))}),t.nodes.forEach(r=>{if(!n.includes(r)){n.push(r);let a=this.findClusterOf(h,r);a===null&&(a=new S,a.add(r),h.push(a)),this.followEdges(t,a,r,n)}}),this.positionCluster(h)}positionCluster(t){this.combineSingleNodeCluster(t);let i=t[0];i.offset(-i.rect.left,-i.rect.top);for(let s=1;s<t.length;s++){const e=t[s],n=e.rect.left-i.rect.right-w,h=e.rect.top-i.rect.top;e.offset(-n,-h),i=e}}combineSingleNodeCluster(t){let i=null;t.forEach(s=>{s.size()===1&&(i===null?i=s:i.concat(s))}),t.forEach(s=>{s.size()===1&&t.splice(t.indexOf(s),1)})}followEdges(t,i,s,e){t.successorsOf(s).forEach(n=>{e.includes(n)||(e.push(n),i.add(n),this.followEdges(t,i,n,e))}),t.predecessorsOf(s).forEach(n=>{e.includes(n)||(e.push(n),i.add(n),this.followEdges(t,i,n,e))})}findClusterOf(t,i){for(const s of t)if(s.contains(i))return s;return null}findBiggestSize(t){return t.nodes.map(i=>Math.max(i.height,i.width)).reduce((i,s)=>Math.max(i,s),0)}getOffset(t){let i=1/0,s=1/0;return t.nodes.forEach(e=>{i=Math.min(i,e.position.x),s=Math.min(s,e.position.y)}),new o(i,s)}done(){return this.tick<1/Math.max(this.graphWidth,this.graphHeight)}calculateGraphSize(t){let i=1/0,s=1/0,e=-1/0,n=-1/0;return t.nodes.forEach(h=>{i=Math.min(i,h.position.x),s=Math.min(s,h.position.y),e=Math.max(e,h.position.x+h.width),n=Math.max(n,h.position.y+h.height)}),{width:e-i,height:n-s}}}class m{constructor(t,i){this.source=t,this.destination=i}static fromJson(t,i){const s=t.find(h=>h.id===i.source),e=t.find(h=>h.id===i.destination),n=new m(s,e);return i.data&&(n.data=i.data),n}toJSON(){return{source:this.source.id,destination:this.destination.id,data:this.data}}}class p{constructor(t){this.rect=new c(0,0,g,g),this.id=t}static fromJson(t){var i,s,e,n;const h=new p(t.id);t.data&&(h.data=t.data);const r=new o((i=t.x)!==null&&i!==void 0?i:0,(s=t.y)!==null&&s!==void 0?s:0),a={width:(e=t.width)!==null&&e!==void 0?e:g,height:(n=t.height)!==null&&n!==void 0?n:g};return h.rect=new c(r.x,r.y,a.width,a.height),h}get x(){return this.position.x}get y(){return this.position.y}get position(){return new o(this.rect.x,this.rect.y)}set position(t){this.rect=new c(t.x,t.y,this.rect.width,this.rect.height)}get width(){return this.rect.width}get height(){return this.rect.height}toJSON(){return{id:this.id,x:this.x,y:this.y,width:this.width,height:this.height,data:this.data}}}class x{constructor(t,i){this.nodes=t,this.edges=i}static fromJson(t){const i=t.nodes.map(p.fromJson),s=t.edges.map(e=>m.fromJson(i,e));return new x(i,s)}toJson(){return{nodes:this.nodes.map(t=>t.toJSON()),edges:this.edges.map(t=>t.toJSON())}}successorsOf(t){return this.getOutEdges(t).map(i=>i.destination)}getOutEdges(t){return this.edges.filter(i=>i.source===t)}predecessorsOf(t){return this.getInEdges(t).map(i=>i.source)}getInEdges(t){return this.edges.filter(i=>i.destination===t)}getEdgeBetween(t,i){return this.edges.find(s=>s.source===t&&s.destination===i)}hasNodes(){return this.nodes.length>0}getNode(t){return this.nodes.find(i=>i.id===t)}}function O(d){const t={nodes:[],edges:[]};for(let i=0;i<d;i++){const[s,e,n]=[Math.random(),Math.random(),Math.random()].map(a=>Math.floor(a*255)),h=`#${s.toString(16)}${e.toString(16)}${n.toString(16)}`,r=s*.299+e*.587+n*.114>186?"#000":"#fff";t.nodes.push({id:`${i}`,data:{name:`Node ${i}`,backgroundColor:h,color:r}})}for(let i=0;i<d;i++)for(let s=0;s<d;s++)i!==s&&t.edges.push({source:`${i}`,destination:`${s}`});return t}const l=x.fromJson(O(20)),u=new I;onmessage=d=>{if(d.data.type==="init"){const{width:t,height:i}=d.data;u.setDimensions(t,i),u.init(l),postMessage({type:"init",width:u.graphWidth,height:u.graphHeight,graph:l.toJson()}),b()}if(d.data.type==="stop"&&A(),d.data.type==="move"){const{x:t,y:i,id:s}=d.data,e=l.getNode(s);e&&(e.position=e.position.add(new o(t,i)),u.copyPositions(l))}};let y;const z=l.nodes.length<100?10:100;function b(){y=setInterval(()=>{u.step(l),u.positionNodes(l),postMessage({type:"tick",graph:l.toJson()})},z)}function A(){clearInterval(y)}})();
